My favorite design pattern is the Observer Pattern.  This is a core part of Reduc, and I also used it as a core design pattern for the MUD I'm working on in my spare time.  Essentially, it is the idea that an object (the *subject*) maintains a list of *dependents* that rely on it for their state. The *subject* is tasked with notifying its *dependents* whenever the information they depend on changes.  In Redux, the data tree (store) is the subject upon which the React components depend. In my game, I maintain the entire game state as a subject upon which individual client states depend.


The anti-pattern I'm the most prone to use is programming by permutation - blindly trying every option I can think of, and moving on when I find something that works, rather than gaining a better understanding of the problem I am working on. This is a dangerous antipattern because it is slow, can introduce undesired side effects to your code, results in duplicating your effort when you encounter the same problem, and can result in an inconsistent codebase where you have solved the same problem in different ways, in different places.


I ran into this on my first pass at building my game, as I created different systems for handling separate types of events that could have been handled more cleanly and powerfully by a single system.  In that case, while I did reuse a great deal of code from the old codebase, I found it worthwhile to restucture the project from the bottom up, after drawing up a diagram of the entire data flow. I think the general lesson is to plot out your software architecture as fully as possible before you begin implementing it.